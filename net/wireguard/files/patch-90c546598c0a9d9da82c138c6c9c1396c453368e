From 90c546598c0a9d9da82c138c6c9c1396c453368e Mon Sep 17 00:00:00 2001
From: "Jason A. Donenfeld" <Jason@zx2c4.com>
Date: Sun, 21 Apr 2019 10:11:36 +0900
Subject: wg-quick: freebsd: workaround SIOCGIFSTATUS race in FreeBSD kernel

---
 src/tools/wg-quick/freebsd.bash | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/tools/wg-quick/freebsd.bash b/src/tools/wg-quick/freebsd.bash
index 9d3a4026..54a08f7b 100755
--- wg-quick/freebsd.bash
+++ wg-quick/freebsd.bash
@@ -274,7 +274,14 @@ monitor_daemon() {
 	# endpoints change.
 	while read -r event; do
 		[[ $event == RTM_* ]] || continue
-		ifconfig "$INTERFACE" >/dev/null 2>&1 || break
+		[[ -e /var/run/wireguard/$INTERFACE.sock ]] || break
+		# The goal is simply to determine whether or not the interface exists. The
+		# straight-forward way of doing this would be `ifconfig $INTERFACE`, but this
+		# invokes the SIOCGIFSTATUS ioctl, which races with interface shutdown inside
+		# the tun driver, resulting in a kernel panic. So we work around it the stupid
+		# way by using the one utility that appears to call if_nametoindex fairly early
+		# and fails if it doesn't exist: `arp`.
+		arp -i "$INTERFACE" -a -n >/dev/null 2>&1 || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
 	done < <(route -n monitor)) & disown
-- 
cgit v1.2.1-20-gc37e

